local world = {}

local costs = {
	[1] = {
		1.0,
		1.0,
		1.0,
		1.0,
		1.21,
		1.41,
		1.41,
		1.41
	},
	[3] = {
		2.0,
		2.0,
		2.0,
		2.0,
		2.41,
		2.41,
		2.41,
		2.41
	}
}
-- SETUP
local TILE_SIZE = 32
local mapWidth = 0
local mapHeight = 0
local direction = 8
local allocate = 0
local typical_adjacent = 8
local cache = true
-- Solve
local startX = 0
local startY = 0
local endX = 0
local endY = 0
local ZORDER_PATH = 0.5
local max_cost = 3.0 -- near

-- Takes a 1 based array index, creates a zero based 2d tile coordinate
local function index_to_coords(index, width)
	local x = math.floor((index + 1) % width)
	local y = math.floor((index + 1) / width)
	return x, y
end

-- Takes a zero based 2d tile coordinate, returns a 2d screen coordinate
local function coords_to_screen(x, y)
	local scrx = TILE_SIZE * x + TILE_SIZE / 2
	local scry = TILE_SIZE * y + TILE_SIZE / 2
	return scrx, scry
end

-- Takes a 2d screen coordinate, returns a zero based 2d tile coordinate
local function screen_to_coords(x, y)
	return math.floor(x / TILE_SIZE), math.floor(y / TILE_SIZE)
end

-- Takes a zero based 2d tile coordinate, and the level width (tiles)
-- Returns a 1 based array index
local function coords_to_index(x, y, width)
	return y * width + x + 1
end

local result = -1
local size = -1
local totalcost = -1
local path = {}

local function solve(coord_x, coord_y)
	endX = coord_x
	endY = coord_y
	result, size, totalcost, path = astar.solve(startX, startY, endX, endY)
end

function init(self)
	profiler.enable_ui(false)
	msg.post(".", "acquire_input_focus")
	--go.animate("/go1", "position.y", go.PLAYBACK_LOOP_PINGPONG, -50, go.EASING_INCIRC, 1)
	local levelx, levely, w, h = tilemap.get_bounds("/go#tiles")

	mapWidth = w
	mapHeight = h
	allocate = mapWidth * mapHeight

	for tile_x = 0, w - 1 do
		for tile_y = 0, h - 1 do
			local tile = tilemap.get_tile("/go#tiles", hash("ground"), tile_x + 1, tile_y + 1)
			world[tile_y * w + tile_x + 1] = tile
		end
	end

	astar.setup(mapWidth, mapHeight, direction, allocate, typical_adjacent, cache)
	astar.setmap(world)
	astar.setcosts(costs)

	startX = 0
	startY = 0
	
	endX = 15
	endY = 4
	result, size, totalcost, path = astar.solve(startX, startY, endX, endY)

	print("result:", result)
	print("size:", size)
	print("totalcost:", totalcost)
	if result == astar.SOLVED then
		for i = 1, size do
			local atart_x, start_y = coords_to_screen(path[i].x, path[i].y)
			if i + 1 < size then
				local next_x, next_y = coords_to_screen(path[i + 1].x, path[i + 1].y)
				msg.post("@render:", "draw_line", {start_point = vmath.vector3(atart_x, start_y, 1), end_point = vmath.vector3(next_x, next_y, 1), color = vmath.vector4(1, 1, 1, 1)})
			end
		end

		for i, v in ipairs(path) do
			local scrx, scry = coords_to_screen(v.x, v.y)
			--local pathitem = factory.create("/go2#factory", vmath.vector3(scrx, scry, ZORDER_PATH + 0.05))
		end
	elseif result == astar.NO_SOLUTION then
		print("NO_SOLUTION")
	elseif result == astar.START_END_SAME then
		print("START_END_SAME")
	end

	--[[ 

	local result, size, totalcost, path = astar.solve(startX, startY, endX, endY)

	print("result:", result)
	print("size:", size)
	print("totalcost:", totalcost)
	if result == astar.SOLVED then
		print("SOLVED")
		for i, v in ipairs(path) do
			print(i, v.x .. " - " .. v.y)
		end
	elseif result == astar.NO_SOLUTION then
		print("NO_SOLUTION")
	elseif result == astar.START_END_SAME then
		print("START_END_SAME")
	end

	print("-------------------------")

	local near_result, near_size, nears = astar.solve_near(startX, startY, max_cost)
	print("near_result:", near_result)
	print("near_size:", near_size)

	if near_result == astar.SOLVED then
		print("SOLVED")
		for i, v in ipairs(nears) do
			print(i, v.x .. " - " .. v.y, v.cost)
		end
	elseif near_result == astar.NO_SOLUTION then
		print("NO_SOLUTION")
	elseif near_result == astar.START_END_SAME then
		print("START_END_SAME")
	end ]]
end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end

function update(self, dt)
	if result == astar.SOLVED then
		msg.post("/go1#test", "update", {cost = totalcost})
		for i = 1, size do
			local atart_x, start_y = coords_to_screen(path[i].x, path[i].y)
			if i + 1 <= size then
				local next_x, next_y = coords_to_screen(path[i + 1].x, path[i + 1].y)
				msg.post("@render:", "draw_line", {start_point = vmath.vector3(atart_x, start_y, 1), end_point = vmath.vector3(next_x, next_y, 1), color = vmath.vector4(1, 1, 1, 1)})
			end
		end

		
	elseif result == astar.NO_SOLUTION then
		print("NO_SOLUTION")
	elseif result == astar.START_END_SAME then
		print("START_END_SAME")
	end
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	if action_id == hash("touch") then
		local coord_x, coord_y = screen_to_coords(action.screen_x, action.screen_y)
		solve(coord_x, coord_y)
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end

local world = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    1,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
}

local costs = {
    [0] = {1.0, 1.0, 1.0, 1.0, 1.41, 1.41, 1.41, 1.41},
    [2] = {2.0, 2.0, 2.0, 2.0, 2.41, 2.41, 2.41, 2.41}
}
-- SETUP
local mapWidth = 10
local mapHeight = 10
local direction = 8
local allocate = mapWidth * mapHeight
local typical_adjacent = 8
local cache = true

-- Solve
local startX = 0
local startY = 0
local endX = 8
local endY = 8
local max_cost = 3.0 -- near

function init(self)
    --[[ 
	
         allocate: How many states should be internally allocated at a time. This
         can be hard to get correct. The higher the value, the more memory
         Patfinder will use.
         - If you have a small map (a few thousand states?) it may make sense
         to pass in the maximum value. This will cache everything, and MicroPather
         will only need one main memory allocation. For a chess board, allocate
         would be set to 8x8 (64)
         - If your map is large, something like 1/4 the number of possible
         states is good.
         - If your state space is huge, use a multiple (5-10x) of the normal
         path. "Occasionally" call Reset() to free unused memory.
		 
		 typicalAdjacent: Used to determine cache size. The typical number of adjacent states
         to a given state. (On a chessboard, 8.) Higher values use a little
         more memory.
		 
		 cache: Turn on path caching. Uses more memory (yet again) but at a huge speed
         advantage if you may call the pather with the same path or sub-path, which
		 is common for pathing over maps in games.

]]
    astar.setup(mapWidth, mapHeight, direction, allocate, typical_adjacent, cache)
    astar.setmap(world)
    astar.setcosts(costs)

    local result, size, totalcost, path = astar.solve(startX, startY, endX, endY)

    print("size:", size)
    print("totalcost:", totalcost)

    if result == astar.SOLVED then
        print("SOLVED")
        for i, v in ipairs(path) do
            print("Tile: ", v.x .. "-" .. v.y)
        end
    elseif result == astar.NO_SOLUTION then
        print("NO_SOLUTION")
    elseif result == astar.START_END_SAME then
        print("START_END_SAME")
    end

    print("-------------------------")

    local near_result, near_size, nears = astar.solve_near(startX, startY, max_cost)

    print("near_size:", near_size)

    if near_result == astar.SOLVED then
        print("SOLVED")
        for i, v in ipairs(nears) do
            print("Tile: ", v.x .. "-" .. v.y)
        end
    elseif near_result == astar.NO_SOLUTION then
        print("NO_SOLUTION")
    elseif near_result == astar.START_END_SAME then
        print("START_END_SAME")
    end
end
